#!/usr/bin/env node
/*
 * LiskHQ/lisky
 * Copyright © 2017 Lisk Foundation
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Unless otherwise agreed in a custom licensing agreement with the Lisk Foundation,
 * no part of this software, including this file, may be copied, modified,
 * propagated, or distributed except according to the terms contained in the
 * LICENSE file.
 *
 * Removal or modification of this copyright notice is prohibited.
 *
 */
const os = require('os');
const lockfile = require('lockfile');
const semver = require('semver');
const packageJSON = require('../package.json');

// eslint-disable-next-line import/extensions,import/no-unresolved
const lisky = require('../dist').default;
// eslint-disable-next-line import/extensions,import/no-unresolved
const execFile = require('../dist/execFile').default;

const nonInteractiveLiskyArg = process.argv[1];
const nonInteractiveCommandArg = process.argv[2];
const configLockfilePath = `${process.env.LISKY_CONFIG_DIR}/config.lock`;

const errorNodeVersion = (expected, actual) =>
	Error(`ERROR: Requires Node.js version ${expected}, but was started with version ${actual}.`);

const exit = code => process.exit(code || 0);

const showWarn = msg => console.warn('\x1b[33m', msg, '\x1b[0m');
const showError = error => console.error('\x1b[31m', error.message, '\x1b[0m');

const showVersion = version => console.info(version);
const execClean = path => {
	showWarn('WARNING: Attempting to remove configuration lockfile. I hope you know what you’re doing.');
	lockfile.unlockSync(path);
};

const isFileInput = command => {
	// eslint-disable-next-line no-underscore-dangle
	const firstCommandWords = lisky.commands.map(c => c._name.split(' ')[0]);
	return firstCommandWords.indexOf(command) === -1;
};

const setEnvironment = () => {
	process.env.LISKY_CONFIG_DIR =
		process.env.LISKY_CONFIG_DIR || `${os.homedir()}/.lisky`;

	process.env.NON_INTERACTIVE_MODE = !(
		nonInteractiveLiskyArg.endsWith('lisky') && process.argv.length === 2
	);
};

const checkNodeVersion = (expected, actual) => {
	if (!semver.satisfies(actual, expected)) {
		throw errorNodeVersion(semver.clean(expected), semver.clean(actual));
	}
};

const handleBasicCommands = (command, lockFilePath, version) => {
	switch (command) {
		case 'clean':
			execClean(lockFilePath);
			return true;
		case '--version':
		case '-v':
			showVersion(version);
			return true;
		default:
			return false;
	}
};

const handleFileInput = (liskyInstnce, command, options, exitFn) => {
	try {
		execFile(liskyInstnce, command, options, exitFn);
		return true;
	} catch (e) {
		return false;
	}
};

const run = () => {
	setEnvironment();
	try {
		checkNodeVersion(packageJSON.engines.node, process.version);
	} catch (err) {
		showError(err);
		exit();
	}

	const handled = handleBasicCommands(
		nonInteractiveCommandArg,
		configLockfilePath,
		packageJSON.version);
	if (handled) {
		exit();
	}

	const commandArgIsFilePath = isFileInput(nonInteractiveCommandArg);
	let fileHandled = false;
	if (commandArgIsFilePath) {
		const nonInteractiveOptions = process.argv.slice(3);
		fileHandled = handleFileInput(
			lisky,
			nonInteractiveCommandArg,
			nonInteractiveOptions,
			exit);
	}
	if (!commandArgIsFilePath || !fileHandled) {
			return process.env.NON_INTERACTIVE_MODE === 'true'
				? lisky.parse(process.argv)
				: lisky;
	}
	return null;
};

module.export = run();

